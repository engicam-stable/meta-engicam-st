From db970ffef9ad49f1945853e5e9891e6be67b6c93 Mon Sep 17 00:00:00 2001
From: FraUtel <francesco.utel@engicam.com>
Date: Mon, 8 Jan 2024 14:58:07 +0100
Subject: [PATCH] Added device tree gpio-export function

---
 .../devicetree/bindings/gpio/gpio.txt         | 46 ++++++++++++
 drivers/gpio/gpiolib-of.c                     | 71 +++++++++++++++++++
 drivers/gpio/gpiolib-sysfs.c                  | 10 ++-
 include/asm-generic/gpio.h                    |  6 ++
 include/linux/gpio/consumer.h                 |  8 +++
 5 files changed, 140 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/gpio/gpio.txt b/Documentation/devicetree/bindings/gpio/gpio.txt
index a8895d339..942393a97 100644
--- a/Documentation/devicetree/bindings/gpio/gpio.txt
+++ b/Documentation/devicetree/bindings/gpio/gpio.txt
@@ -329,3 +329,49 @@ were referenced by any gpio-ranges property to contain a property named
 However, that property may still exist in older device trees for
 compatibility reasons, and would still be required even in new device
 trees that need to be compatible with older software.
+
+3) gpio-export
+--------------
+
+gpio-export will allow you to export a GPIO line to linux sysfs.
+Can be used to describe hw GPIO lines by "name" and to have them exported at
+boot-time to make it convenient for users.
+
+required properties:
+- compatible: Should be "gpio-export"
+
+in each child node will represent a GPIO line
+
+required properties:
+- gpios: GPIO line to export
+
+optional properties:
+ - label: export name, if not present, child node name used
+ - output: to set it as output with default value
+	   if not present gpio as input
+ - direction_may_change: boolean to allow the direction to be controllable
+
+Example:
+
+gpio_export {
+	compatible = "gpio-export";
+	#size-cells = <0>;
+
+	in {
+		gpio-export,name = "in";
+		gpio-export,input = <1>;
+		gpios = <&pioC 20 0>;
+	};
+
+	out {
+		gpio-export,name = "out";
+		gpio-export,output = <1>;
+		gpios = <&pioC 21 0>;
+	};
+
+	in_out {
+		gpio-export,name = "in_out";
+		gpio-export,direction_may_change;
+		gpios = <&pioC 22 0>;
+	};
+};
diff --git a/drivers/gpio/gpiolib-of.c b/drivers/gpio/gpiolib-of.c
index 2f895a2b8..5179a3e7b 100644
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -19,6 +19,8 @@
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/slab.h>
 #include <linux/gpio/machine.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
 
 #include "gpiolib.h"
 #include "gpiolib-of.h"
@@ -1039,3 +1041,72 @@ void of_gpiochip_remove(struct gpio_chip *chip)
 {
 	of_node_put(chip->of_node);
 }
+
+#ifdef CONFIG_GPIO_SYSFS
+
+static struct of_device_id gpio_export_ids[] = {
+	{ .compatible = "gpio-export" },
+	{ /* sentinel */ }
+};
+
+static int of_gpio_export_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *cnp;
+	u32 val;
+	int nb = 0;
+
+	for_each_child_of_node(np, cnp) {
+		const char *name = NULL;
+		int gpio;
+		bool dmc;
+		int max_gpio = 1;
+		int i;
+
+		of_property_read_string(cnp, "gpio-export,name", &name);
+
+		if (!name)
+			max_gpio = of_gpio_count(cnp);
+
+		for (i = 0; i < max_gpio; i++) {
+			unsigned flags = 0;
+			enum of_gpio_flags of_flags;
+
+			gpio = of_get_gpio_flags(cnp, i, &of_flags);
+			if (!gpio_is_valid(gpio))
+				return gpio;
+
+			if (of_flags == OF_GPIO_ACTIVE_LOW)
+				flags |= GPIOF_ACTIVE_LOW;
+
+			if (!of_property_read_u32(cnp, "gpio-export,output", &val))
+				flags |= val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+			else
+				flags |= GPIOF_IN;
+
+			if (devm_gpio_request_one(&pdev->dev, gpio, flags, name ? name : of_node_full_name(np)))
+				continue;
+
+			dmc = of_property_read_bool(cnp, "gpio-export,direction_may_change");
+			gpio_export_with_name(gpio, dmc, name);
+			nb++;
+		}
+	}
+
+	dev_info(&pdev->dev, "%d gpio(s) exported\n", nb);
+
+	return 0;
+}
+
+static struct platform_driver gpio_export_driver = {
+	.driver		= {
+		.name		= "gpio-export",
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(gpio_export_ids),
+	},
+	.probe		= of_gpio_export_probe,
+};
+
+module_platform_driver(gpio_export_driver);
+
+#endif
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
index 728f6c687..7e03dbc5d 100644
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -564,7 +564,7 @@ static struct class gpio_class = {
  *
  * Returns zero on success, else an error.
  */
-int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
+int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name)
 {
 	struct gpio_chip	*chip;
 	struct gpio_device	*gdev;
@@ -626,6 +626,8 @@ int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 	offset = gpio_chip_hwgpio(desc);
 	if (chip->names && chip->names[offset])
 		ioname = chip->names[offset];
+	if (name)
+		ioname = name;
 
 	dev = device_create_with_groups(&gpio_class, &gdev->dev,
 					MKDEV(0, 0), data, gpio_groups,
@@ -647,6 +649,12 @@ int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 	gpiod_dbg(desc, "%s: status %d\n", __func__, status);
 	return status;
 }
+EXPORT_SYMBOL_GPL(__gpiod_export);
+
+int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
+{
+	return __gpiod_export(desc, direction_may_change, NULL);
+}
 EXPORT_SYMBOL_GPL(gpiod_export);
 
 static int match_export(struct device *dev, const void *desc)
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index aea9aee1f..231fe2f9e 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -125,6 +125,12 @@ static inline int gpio_export(unsigned gpio, bool direction_may_change)
 	return gpiod_export(gpio_to_desc(gpio), direction_may_change);
 }
 
+int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
+static inline int gpio_export_with_name(unsigned gpio, bool direction_may_change, const char *name)
+{
+	return __gpiod_export(gpio_to_desc(gpio), direction_may_change, name);
+}
+
 static inline int gpio_export_link(struct device *dev, const char *name,
 				   unsigned gpio)
 {
diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h
index 901aab89d..e40553055 100644
--- a/include/linux/gpio/consumer.h
+++ b/include/linux/gpio/consumer.h
@@ -713,6 +713,7 @@ static inline void devm_acpi_dev_remove_driver_gpios(struct device *dev) {}
 
 #if IS_ENABLED(CONFIG_GPIOLIB) && IS_ENABLED(CONFIG_GPIO_SYSFS)
 
+int _gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
 int gpiod_export(struct gpio_desc *desc, bool direction_may_change);
 int gpiod_export_link(struct device *dev, const char *name,
 		      struct gpio_desc *desc);
@@ -720,6 +721,13 @@ void gpiod_unexport(struct gpio_desc *desc);
 
 #else  /* CONFIG_GPIOLIB && CONFIG_GPIO_SYSFS */
 
+static inline int _gpiod_export(struct gpio_desc *desc,
+			       bool direction_may_change,
+			       const char *name)
+{
+	return -ENOSYS;
+}
+
 static inline int gpiod_export(struct gpio_desc *desc,
 			       bool direction_may_change)
 {
-- 
2.17.1

