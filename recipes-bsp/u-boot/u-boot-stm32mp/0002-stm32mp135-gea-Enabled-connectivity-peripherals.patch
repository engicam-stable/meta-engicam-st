From 5a101ec46252d4f6dd8e7f7427ae8857a298fc0e Mon Sep 17 00:00:00 2001
From: Franesco Utel <francesco.utel@engicam.com>
Date: Wed, 27 Jul 2022 11:11:26 +0200
Subject: [PATCH] stm32mp135 gea - Enabled connectivity peripherals

---
 .../arm/dts/stm32mp135d-gea-starterkit-mx.dts | 338 +++++++++++++++++-
 .../dts/stm32mp135d-gea-starterkit-mx.dts.bak | 337 ++++++++++++++++-
 2 files changed, 664 insertions(+), 11 deletions(-)

diff --git a/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts b/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts
index db15c8cf71..1f0cb483ff 100644
--- a/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts
+++ b/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts
@@ -15,6 +15,10 @@
 #include "stm32mp13xd.dtsi"
 
 /* USER CODE BEGIN includes */
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
 /* USER CODE END includes */
 
 / {
@@ -49,8 +53,8 @@
 
 	/* USER CODE BEGIN root */
 	aliases {
-		//ethernet0 = &eth1;
-		//ethernet1 = &eth2;
+		ethernet0 = &eth1;
+		ethernet1 = &eth2;
 		serial0 = &uart4;
 		serial1 = &uart8;
 		serial2 = &usart2;
@@ -90,6 +94,124 @@
 
 &pinctrl {
 
+	eth1_pins_mx: eth1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 11, AF11)>, /* ETH1_CLK */
+					 <STM32_PINMUX('B', 11, AF11)>, /* ETH1_TX_EN */
+					 <STM32_PINMUX('G', 2, AF11)>, /* ETH1_MDC */
+					 <STM32_PINMUX('G', 13, AF11)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, AF11)>; /* ETH1_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 2, AF11)>; /* ETH1_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 1, AF10)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, AF11)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, AF11)>; /* ETH1_RXD1 */
+			bias-disable;
+		};
+	};
+
+	eth1_sleep_pins_mx: eth1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
+					 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH1_CLK */
+					 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH1_TX_EN */
+					 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH1_RXD1 */
+					 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH1_MDC */
+					 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, ANALOG)>; /* ETH1_TXD1 */
+		};
+	};
+
+	eth2_pins_mx: eth2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 12, AF11)>, /* ETH2_CRS_DV */
+					 <STM32_PINMUX('E', 2, AF10)>, /* ETH2_RXD1 */
+					 <STM32_PINMUX('F', 4, AF11)>; /* ETH2_RXD0 */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 2, AF11)>; /* ETH2_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 6, AF11)>, /* ETH2_TX_EN */
+					 <STM32_PINMUX('F', 7, AF11)>, /* ETH2_TXD0 */
+					 <STM32_PINMUX('G', 5, AF10)>, /* ETH2_MDC */
+					 <STM32_PINMUX('G', 8, AF13)>, /* ETH2_CLK */
+					 <STM32_PINMUX('G', 11, AF10)>; /* ETH2_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	eth2_sleep_pins_mx: eth2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* ETH2_CRS_DV */
+					 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH2_MDIO */
+					 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH2_RXD1 */
+					 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH2_RXD0 */
+					 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH2_TX_EN */
+					 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH2_TXD0 */
+					 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH2_MDC */
+					 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH2_CLK */
+					 <STM32_PINMUX('G', 11, ANALOG)>; /* ETH2_TXD1 */
+		};
+	};
+
+	fdcan1_pins_mx: fdcan1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 0, AF9)>; /* FDCAN1_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 10, AF9)>; /* FDCAN1_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	fdcan1_sleep_pins_mx: fdcan1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, ANALOG)>, /* FDCAN1_RX */
+					 <STM32_PINMUX('E', 10, ANALOG)>; /* FDCAN1_TX */
+		};
+	};
+
+	fdcan2_pins_mx: fdcan2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 1, AF9)>; /* FDCAN2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 3, AF9)>; /* FDCAN2_RX */
+			bias-disable;
+		};
+	};
+
+	fdcan2_sleep_pins_mx: fdcan2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 1, ANALOG)>, /* FDCAN2_TX */
+					 <STM32_PINMUX('G', 3, ANALOG)>; /* FDCAN2_RX */
+		};
+	};
+
 	sdmmc1_pins_mx: sdmmc1_mx-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -218,6 +340,62 @@
 		};
 	};
 
+	uart8_pins_mx: uart8_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, AF8)>; /* UART8_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-disable;
+		};
+	};
+
+	uart8_sleep_pins_mx: uart8_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>, /* UART8_TX */
+					 <STM32_PINMUX('F', 9, ANALOG)>; /* UART8_RX */
+		};
+	};
+
+	usart2_pins_mx: usart2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>; /* USART2_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 4, AF3)>, /* USART2_DE */
+					 <STM32_PINMUX('H', 12, AF1)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	usart2_sleep_pins_mx: usart2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_DE */
+					 <STM32_PINMUX('D', 15, ANALOG)>, /* USART2_RX */
+					 <STM32_PINMUX('H', 12, ANALOG)>; /* USART2_TX */
+		};
+	};
+
+	usb_otg_hs_pins_mx: usb_otg_hs_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>, /* USB_OTG_HS_ID */
+					 <STM32_PINMUX('I', 7, ANALOG)>; /* USB_OTG_HS_VBUS */
+		};
+	};
+
+	usb_otg_hs_sleep_pins_mx: usb_otg_hs_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>, /* USB_OTG_HS_ID */
+					 <STM32_PINMUX('I', 7, ANALOG)>; /* USB_OTG_HS_VBUS */
+		};
+	};
+
 	/* USER CODE BEGIN pinctrl */
 	/* USER CODE END pinctrl */
 };
@@ -253,6 +431,85 @@
 	/* USER CODE END dmamux1 */
 };
 
+&eth1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth1_pins_mx>;
+	pinctrl-1 = <&eth1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN eth1 */
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+
+	st,ext-phyclk;
+	st,eth-ref-clk-sel;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+					compatible = "ethernet-phy-id0007.c131";
+					reset-gpios =  <&gpioc 2 GPIO_ACTIVE_LOW>;
+					reg = <0>;
+					//interrupt-parent = <&gpiog>;
+					//interrupts = <12 IRQ_TYPE_EDGE_RISING>;
+				};
+	};
+	/* USER CODE END eth1 */
+};
+
+&eth2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth2_pins_mx>;
+	pinctrl-1 = <&eth2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN eth2 */
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios = <&gpioe 14 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+		};
+	};
+	/* USER CODE END eth2 */
+};
+
+&m_can1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fdcan1_pins_mx>;
+	pinctrl-1 = <&fdcan1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN m_can1 */
+	/* USER CODE END m_can1 */
+};
+
+&m_can2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fdcan2_pins_mx>;
+	pinctrl-1 = <&fdcan2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN m_can2 */
+	/* USER CODE END m_can2 */
+};
+
 &mdma{
 	status = "okay";
 
@@ -286,7 +543,7 @@
 	disable-wp;
 	st,neg-edge;
 	bus-width = <4>;
-	vmmc-supply = <&scmi_vdd_sd>;
+	vmmc-supply = <&v3v3_ao>;
 	/* USER CODE END sdmmc1 */
 };
 
@@ -315,6 +572,81 @@
 	/* USER CODE END uart4 */
 };
 
+&uart8{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&uart8_pins_mx>;
+	pinctrl-1 = <&uart8_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN uart8 */
+	/* USER CODE END uart8 */
+};
+
+&usart2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_mx>;
+	pinctrl-1 = <&usart2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usart2 */
+	linux,rs485-enabled-at-boot-time;
+	/* USER CODE END usart2 */
+};
+
+&usbh_ehci{
+	status = "okay";
+
+	/* USER CODE BEGIN usbh_ehci */
+	phys = <&usbphyc_port0>;
+	/* USER CODE END usbh_ehci */
+};
+
+&usbh_ohci{
+	status = "okay";
+
+	/* USER CODE BEGIN usbh_ohci */
+	phys = <&usbphyc_port0>;
+	/* USER CODE END usbh_ohci */
+};
+
+&usbotg_hs{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usb_otg_hs_pins_mx>;
+	pinctrl-1 = <&usb_otg_hs_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usbotg_hs */
+	/* USER CODE END usbotg_hs */
+};
+
+&usbphyc{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc */
+	/* USER CODE END usbphyc */
+};
+
+&usbphyc_port0{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc_port0 */
+	phy-supply = <&scmi_vdd_usb>;
+
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&scmi_v3v3_sw>;
+	};
+	/* USER CODE END usbphyc_port0 */
+};
+
+&usbphyc_port1{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc_port1 */
+	phy-supply = <&scmi_vdd_usb>;
+	/* USER CODE END usbphyc_port1 */
+};
+
 /* USER CODE BEGIN addons */
 &scmi_regu {
 	scmi_vddcpu: voltd-vddcpu {
diff --git a/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts.bak b/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts.bak
index 2ada68908a..0304089614 100644
--- a/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts.bak
+++ b/arch/arm/dts/stm32mp135d-gea-starterkit-mx.dts.bak
@@ -15,6 +15,10 @@
 #include "stm32mp13xd.dtsi"
 
 /* USER CODE BEGIN includes */
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
 /* USER CODE END includes */
 
 / {
@@ -49,8 +53,8 @@
 
 	/* USER CODE BEGIN root */
 	aliases {
-		//ethernet0 = &eth1;
-		//ethernet1 = &eth2;
+		ethernet0 = &eth1;
+		ethernet1 = &eth2;
 		serial0 = &uart4;
 		serial1 = &uart8;
 		serial2 = &usart2;
@@ -90,6 +94,124 @@
 
 &pinctrl {
 
+	eth1_pins_mx: eth1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 11, AF11)>, /* ETH1_CLK */
+					 <STM32_PINMUX('B', 11, AF11)>, /* ETH1_TX_EN */
+					 <STM32_PINMUX('G', 2, AF11)>, /* ETH1_MDC */
+					 <STM32_PINMUX('G', 13, AF11)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, AF11)>; /* ETH1_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 2, AF11)>; /* ETH1_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 1, AF10)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, AF11)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, AF11)>; /* ETH1_RXD1 */
+			bias-disable;
+		};
+	};
+
+	eth1_sleep_pins_mx: eth1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
+					 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH1_CLK */
+					 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH1_TX_EN */
+					 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH1_RXD1 */
+					 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH1_MDC */
+					 <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_TXD0 */
+					 <STM32_PINMUX('G', 14, ANALOG)>; /* ETH1_TXD1 */
+		};
+	};
+
+	eth2_pins_mx: eth2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 12, AF11)>, /* ETH2_CRS_DV */
+					 <STM32_PINMUX('E', 2, AF10)>, /* ETH2_RXD1 */
+					 <STM32_PINMUX('F', 4, AF11)>; /* ETH2_RXD0 */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 2, AF11)>; /* ETH2_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 6, AF11)>, /* ETH2_TX_EN */
+					 <STM32_PINMUX('F', 7, AF11)>, /* ETH2_TXD0 */
+					 <STM32_PINMUX('G', 5, AF10)>, /* ETH2_MDC */
+					 <STM32_PINMUX('G', 8, AF13)>, /* ETH2_CLK */
+					 <STM32_PINMUX('G', 11, AF10)>; /* ETH2_TXD1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	eth2_sleep_pins_mx: eth2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* ETH2_CRS_DV */
+					 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH2_MDIO */
+					 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH2_RXD1 */
+					 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH2_RXD0 */
+					 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH2_TX_EN */
+					 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH2_TXD0 */
+					 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH2_MDC */
+					 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH2_CLK */
+					 <STM32_PINMUX('G', 11, ANALOG)>; /* ETH2_TXD1 */
+		};
+	};
+
+	fdcan1_pins_mx: fdcan1_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 0, AF9)>; /* FDCAN1_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 10, AF9)>; /* FDCAN1_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	fdcan1_sleep_pins_mx: fdcan1_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, ANALOG)>, /* FDCAN1_RX */
+					 <STM32_PINMUX('E', 10, ANALOG)>; /* FDCAN1_TX */
+		};
+	};
+
+	fdcan2_pins_mx: fdcan2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 1, AF9)>; /* FDCAN2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 3, AF9)>; /* FDCAN2_RX */
+			bias-disable;
+		};
+	};
+
+	fdcan2_sleep_pins_mx: fdcan2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 1, ANALOG)>, /* FDCAN2_TX */
+					 <STM32_PINMUX('G', 3, ANALOG)>; /* FDCAN2_RX */
+		};
+	};
+
 	sdmmc1_pins_mx: sdmmc1_mx-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -151,13 +273,13 @@
 					 <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
 					 <STM32_PINMUX('B', 15, AF10)>, /* SDMMC2_D1 */
 					 <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
-			bias-disable;
+			bias-pull-up;
 			drive-push-pull;
 			slew-rate = <1>;
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC2_CK */
-			bias-disable;
+			bias-pull-up;
 			drive-push-pull;
 			slew-rate = <3>;
 		};
@@ -169,19 +291,19 @@
 					 <STM32_PINMUX('B', 4, AF10)>, /* SDMMC2_D3 */
 					 <STM32_PINMUX('B', 14, AF10)>, /* SDMMC2_D0 */
 					 <STM32_PINMUX('B', 15, AF10)>; /* SDMMC2_D1 */
-			bias-disable;
+			bias-pull-up;
 			drive-push-pull;
 			slew-rate = <1>;
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC2_CK */
-			bias-disable;
+			bias-pull-up;
 			drive-push-pull;
 			slew-rate = <3>;
 		};
 		pins3 {
 			pinmux = <STM32_PINMUX('G', 6, AF10)>; /* SDMMC2_CMD */
-			bias-disable;
+			bias-pull-up;
 			drive-open-drain;
 			slew-rate = <1>;
 		};
@@ -218,6 +340,60 @@
 		};
 	};
 
+	uart8_pins_mx: uart8_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, AF8)>; /* UART8_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-disable;
+		};
+	};
+
+	uart8_sleep_pins_mx: uart8_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>, /* UART8_TX */
+					 <STM32_PINMUX('F', 9, ANALOG)>; /* UART8_RX */
+		};
+	};
+
+	usart2_pins_mx: usart2_mx-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>; /* USART2_RX */
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 4, AF3)>, /* USART2_DE */
+					 <STM32_PINMUX('H', 12, AF1)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	usart2_sleep_pins_mx: usart2_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_DE */
+					 <STM32_PINMUX('D', 15, ANALOG)>, /* USART2_RX */
+					 <STM32_PINMUX('H', 12, ANALOG)>; /* USART2_TX */
+		};
+	};
+
+	usb_otg_hs_pins_mx: usb_otg_hs_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* USB_OTG_HS_ID */
+		};
+	};
+
+	usb_otg_hs_sleep_pins_mx: usb_otg_hs_sleep_mx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* USB_OTG_HS_ID */
+		};
+	};
+
 	/* USER CODE BEGIN pinctrl */
 	/* USER CODE END pinctrl */
 };
@@ -253,6 +429,85 @@
 	/* USER CODE END dmamux1 */
 };
 
+&eth1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth1_pins_mx>;
+	pinctrl-1 = <&eth1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN eth1 */
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+
+	st,ext-phyclk;
+	st,eth-ref-clk-sel;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+					compatible = "ethernet-phy-id0007.c131";
+					reset-gpios =  <&gpioc 2 GPIO_ACTIVE_LOW>;
+					reg = <0>;
+					//interrupt-parent = <&gpiog>;
+					//interrupts = <12 IRQ_TYPE_EDGE_RISING>;
+				};
+	};
+	/* USER CODE END eth1 */
+};
+
+&eth2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&eth2_pins_mx>;
+	pinctrl-1 = <&eth2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN eth2 */
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios = <&gpioe 14 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+		};
+	};
+	/* USER CODE END eth2 */
+};
+
+&m_can1{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fdcan1_pins_mx>;
+	pinctrl-1 = <&fdcan1_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN m_can1 */
+	/* USER CODE END m_can1 */
+};
+
+&m_can2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fdcan2_pins_mx>;
+	pinctrl-1 = <&fdcan2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN m_can2 */
+	/* USER CODE END m_can2 */
+};
+
 &mdma{
 	status = "okay";
 
@@ -286,7 +541,7 @@
 	disable-wp;
 	st,neg-edge;
 	bus-width = <4>;
-	vmmc-supply = <&scmi_vdd_sd>;
+	vmmc-supply = <&v3v3_ao>;
 	/* USER CODE END sdmmc1 */
 };
 
@@ -315,6 +570,72 @@
 	/* USER CODE END uart4 */
 };
 
+&uart8{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&uart8_pins_mx>;
+	pinctrl-1 = <&uart8_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN uart8 */
+	/* USER CODE END uart8 */
+};
+
+&usart2{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usart2_pins_mx>;
+	pinctrl-1 = <&usart2_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usart2 */
+	linux,rs485-enabled-at-boot-time;
+	/* USER CODE END usart2 */
+};
+
+&usbh_ehci{
+	status = "okay";
+
+	/* USER CODE BEGIN usbh_ehci */
+	/* USER CODE END usbh_ehci */
+};
+
+&usbh_ohci{
+	status = "okay";
+
+	/* USER CODE BEGIN usbh_ohci */
+	/* USER CODE END usbh_ohci */
+};
+
+&usbotg_hs{
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&usb_otg_hs_pins_mx>;
+	pinctrl-1 = <&usb_otg_hs_sleep_pins_mx>;
+	status = "okay";
+
+	/* USER CODE BEGIN usbotg_hs */
+	/* USER CODE END usbotg_hs */
+};
+
+&usbphyc{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc */
+	/* USER CODE END usbphyc */
+};
+
+&usbphyc_port0{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc_port0 */
+	/* USER CODE END usbphyc_port0 */
+};
+
+&usbphyc_port1{
+	status = "okay";
+
+	/* USER CODE BEGIN usbphyc_port1 */
+	/* USER CODE END usbphyc_port1 */
+};
+
 /* USER CODE BEGIN addons */
 &scmi_regu {
 	scmi_vddcpu: voltd-vddcpu {
